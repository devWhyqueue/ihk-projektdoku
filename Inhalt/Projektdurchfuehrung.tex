% !TEX root = ../Projektdokumentation.tex
\section{Projektdurchführung} 
\label{sec:Projektdurchführung}
Das Kapitel Projektdurchführung befasst sich mit allen acht, in Abschnitt \ref{sec:Projektphasen} erwähnten, Projektphasen. Prozessschritte und Vorgehensweisen werden differenziert dargestellt und jegliche Abweichungen vom Projektantrag werden umfassend begründet werden. Zudem werden Entscheidungen zu auftretenden Anpassungen und daraus resultierende Folgen erläutert werden.


\subsection{Wirtschaftlichkeitsanalyse}
\label{sec:Wirtschaftlichkeitsanalyse}
Eine Wirtschaftlichkeitsanalyse stellt die Kosten und das erwartete Ergebnis eines Projektes gegenüber. Ziel ist die Überprüfung der Rentabilität \bzw Wirtschaftlichkeit. Gründe für erfolgreiche Projekte sollen identifiziert und die Wirkung von Schwächen begrenzt werden.\footnote{\Vgl \cite{finlex:wa}}\\

\subsubsection{\gqq{Make or Buy}-Entscheidung}
\label{sec:MakeOrBuyEntscheidung}
Eine umfangreiche Recherche innerhalb des eigenen Unternehmens und aller verfügbaren Internetquellen ergab, dass schon mehrere Lösungen zur Darstellung von Statistiken für die Berichterstellungsplattform \ac{SSRS} existieren. Ein repräsentatives Beispiel aller online verfügbaren Ansätze für die Erhebung von Metadaten liefert der Lösungsansatz des Autors Jeff Pries. Er stellt eine Reihe von Informationen über Benutzer, Berichtsausführungen und Performance als Report innerhalb der \ac{SSRS} dar.\footnote{\Vgl \cite{pries:usage}} Da aber vom Auftraggeber eine \gqq{Implementierung einer Web-Applikation}\footnote{\cite{Projektantrag}} gefordert wurde, die unabhängig und außerhalb des Report-Servers besteht, entspricht keine der gefundenen Lösungen den Anforderungen. Folglich wurde die Entscheidung gefällt \projektName in Form einer Individualsoftware zu realisieren. Diese Umsetzung wird außerdem nicht an externe Dienstleister vergeben, sondern an die interne IT-Abteilung, weil diese am besten mit den Rahmenbedingungen vertraut ist. So kann gezielt auf die Bedürfnisse des Auftraggebers \teamName eingegangen werden, um einen hohen Individualisierungsgrad zu erzielen.


\subsubsection{Projektkosten}
\label{sec:Projektkosten}
Die Kosten eines Projekts setzen sich aus Personal- und Ressourcenkosten zusammen. Die Kalkulation der Personalkosten erfolgt dabei nicht durch Auflistung der acht Vorgänge und ihrer geschätzten monetären Aufwände, sondern anhand des je Projektrolle aufgewendeten Zeitaufwands. Die angegebenen Stundensätze wurden nicht eigenständig berechnet, sondern bei der Personalabteilung der \ac{KVWL} erfragt. In den Stundensätzen sind sämtliche zusätzlich anfallende Kostenfaktoren (wie Ressourcen- und Fixkosten) enthalten. Da bei \projektName keine Materialkosten anfallen, repräsentieren die Personalkosten die Gesamtprojektkosten. In der untenstehenden Tabelle \ref{tab:Kostenaufstellung} befindet sich die Aufstellung der Kosten.
\tabelle{Kostenaufstellung}{tab:Kostenaufstellung}{Kostenaufstellung.tex}

\subsubsection{Amortisationsdauer}
\label{sec:Amortisationsdauer}
Durch die einfache Fehlerkennung und die schrittweise Reduktion von ungenutzten Berichten und Datenquellen innerhalb der Webanwendung bietet \projektName signifikante Zeiteinsparungen bei der Verwaltung der Berichte.
\begin{itemize}
	\item Welche monetären Vorteile bietet das Projekt (\zB Einsparung von Lizenzkosten, Arbeitszeitersparnis, bessere Usability, Korrektheit)?
	\item Wann hat sich das Projekt amortisiert?
\end{itemize}

\paragraph{Berechnung der Amortisationsdauer} ~\\
Bei einer Zeiteinsparung von 10 Minuten am Tag für jeden der 8 Anwender und 220 Arbeitstagen im Jahr ergibt sich eine gesamte Zeiteinsparung von 
\begin{eqnarray}
8 \cdot 220 \mbox{ Tage/Jahr} \cdot 10 \mbox{ min/Tag} = 17600 \mbox{ min/Jahr} \approx 293 \mbox{ h/Jahr} 
\end{eqnarray}

Dadurch ergibt sich eine jährliche Einsparung von 
\begin{eqnarray}
293 \mbox{h} \cdot \eur{75}{\mbox{/h}} = \eur{21975}
\end{eqnarray}

Die Amortisationszeit beträgt also $\frac{\eur{4350}}{\eur{21975}\mbox{/Jahr}} \approx 0,2 \mbox{ Jahre} \approx 10 \mbox{ Wochen}$.

\subsection{Einarbeitung in das Projektumfeld}
\label{sec:Einarbeitung}
Der Projektverantwortliche \autorName\xspace setzte sich zunächst mit dem Prozess der Berichtserstellung und -verwaltung des \ac{CFT} \teamName auseinander. Hierzu musste sowohl der Umgang mit dem Berichtsdesigner als auch mit dem zugehörigen Webportal erlernt werden. Außerdem mussten insbesondere die von den \ac{SSRS} persistierten Daten analysiert werden, um Statistiken über jene erfassen zu können.

\subsubsection{Berichtserstellung}
\label{sec:Berichtserstellung}
Die Erstellung von Reports erfolgt bei der \ac{KVWL} mithilfe der \ac{IDE} Visual Studio. Es werden zuerst mit einem Assistenten Datenquellen für den Bericht festgelegt und die gewünschten Tabellen angegeben. Daraufhin kann der Bericht beliebig mit einer Reihe von Grafikelementen (Tabellen, Diagramme, Textfelder \etc) gestaltet werden.

\subsubsection{Berichtsverwaltung}
\label{sec:Berichtsverwaltung}
Zur Verwaltung der Berichte wird ein in SharePoint integriertes Webportal eingesetzt, das alle publizierten Reports in einer Ordnerstruktur auflistet. Die Verzeichnishierarchien sind wie im Windows-Explorer durchsuchbar und die Reports mit der Angabe der benötigten Parameter einfach auszuführen.

\subsubsection{Analyse der Datenstrukturen}
\label{sec:Datenstrukturen}
Die von \ac{SSRS} gesammelten Daten werden in relationalen Tabellen auf dem SQL Server in der ReportServer-Datenbank abgelegt. Alle für die Erhebung von Statistiken erforderlichen Tabellen werden in dem nachfolgenden vereinfachten relationalen Datenmodell in \Abbildung{Datenmodell} mitsamt ihrer Abhängigkeiten aufgelistet.
\begin{figure}[htb]
	\centering
	\includegraphicsKeepAspectRatio{Datenmodell.png}{0.5}
	\caption{Relationales Datenmodell (vereinfacht)}
	\label{fig:Datenmodell}
\end{figure}

\paragraph{DataSource} ~\\
\label{p:DataSource}
Die Tabelle DataSource beinhaltet alle Datenquellen des Report-Servers. Neben dem im Diagramm aufgeführten Attribut \gqq{Name} enthält es weitere für Datenquellen relevante Informationen wie Zugangsdaten oder weitere Optionen.\\
Über den Fremdschlüssel \gqq{ItemID} erreicht man das zugehörige Catalog-Item. Dies kann ein DataSource-Item (\gqq{Type}=5) oder ein Report-Item (\gqq{Type}=2) sein. Ein zugehöriges DataSource-Item in der Catalog-Tabelle enthält weitere Informationen zur DataSource (wie \gqq{Path}, also Speicherort). Verweist die \gqq{ItemID} auf ein Report-Item, nutzt dieses die entsprechende DataSource.\\
Die \gqq{LinkID} zeigt immer auf ein zugehöriges DataSource-Item in der Catalog-Tabelle. Datensätze in der DataSource-Tabelle mit einer \gqq{ItemID}, die auf ein Report-Item verweist, können hierbei beliebig viele DataSource-Items haben. Dies führt dann zu mehreren Zeilen in der DataSource-Tabelle mit denselben ItemIDs, aber unterschiedlichen LinkIDs.\\
Einträge mit einer \gqq{ItemID}, die ein DataSource-Item referenziert, haben jedoch immer eine \gqq{LinkID}=NULL, da sie ja bereits über die \gqq{ItemID} an die Catalog-Tabelle geknüpft sind (und da ein DataSource-Item ja keine abhängigen DataSource-Items haben kann).

\paragraph{Catalog} ~\\
\label{p:Catalog}
Der Catalog umfasst alle für den Report-Server relevanten Items. Darunter befinden sich die bereits oben erwähnten Reports und Datenquellen, aber auch \zB Datasets, Folders oder Resources (für dieses Projekt irrelevant).

\paragraph{ExecutionLogStorage} ~\\
\label{p:ExecutionLogStorage}
Einträge im ExecutionLogStorage repräsentieren die Ausführung von Berichten über das Webportal. Wird ein Report ausgeführt, loggt der Report-Server \ua die Ladezeit, den Ausführungsstatus und den aufrufenden Benutzer.

\paragraph{ConfigurationInfo} ~\\
\label{p:ConfigurationInfo}
Hier befinden sich globale Konfigurationen des Report-Servers (SessionTimeout, ExecutionLogLevel, MaxFileSizeMb) als Key-Value-Pairs.

\Zwischenstand{Einarbeitung in das Projektumfeld}{Einarbeitung}

\subsection{Anforderungsanalyse}
\label{sec:Anforderungsanalyse}

\subsubsection{Anforderungserhebung}
\label{sec:Anforderungserhebung}
Die Anforderungen wurden im Rahmen eines Interviews mit den künftigen Benutzern der Applikation erfasst. Dadurch ergab sich der Vorteil, dass die Wünsche des Kunden bereits zu Beginn der Projektphase aufgenommen werden konnten. Außerdem konnte die aktuelle Situation praktisch begutachtet werden, um die zentralen Probleme, Erwartungen und Ziele des Teams \teamName zu identifizieren.

\subsubsection{Ist-Zustand}
\label{sec:Ist}
Aktuell bietet das von den \ac{SSRS} zu Verfügung gestellte Webportal zwar komfortablen Zugriff auf alle erstellten Berichte, liefert aber keine Statistiken oder Metadaten zu deren Status, Performance oder Fehleranfälligkeit. Auch die in einer nur sehr geringen Anzahl vorhandenen Metadaten-Berichte bieten nur unzureichenden Überblick über die Gesamtsituation. Es ist zur Zeit ein hohes Maß an Fachwissen erforderlich, um Abhängigkeiten und mögliche Fehlerquellen zeit- und kosteneffizient zu identifizieren.

\subsubsection{Soll-Zustand}
\label{sec:Soll}
\projektName soll den Benutzern in einer ähnlich intuitiven Form wie beim \ac{SSRS}-Webportal Berichte ausgeführt werden, Zugang zu diversen Statistiken bieten, die ohne tiefgehendes Fachwissen verstanden werden können. Diese sollen dann für die Reduzierung der ungenutzten Berichte und Datenquellen genutzt werden und die Report-Verwaltung und Fehleranalyse allgemein erleichtern.

\subsubsection{Anwendungsfälle}
\label{sec:Anwendungsfaelle}
Die ermittelten Anforderungsfälle werden in dem folgenden Anwendungsfalldiagramm dargestellt. Detailliertere User Stories befinden sich im \Anhang{app:UserStories}.
\begin{figure}[htb]
	\centering
	\includegraphicsKeepAspectRatio{Anwendungsfalldiagramm.png}{0.7}
	\caption{Anwendungsfalldiagramm}
	\label{fig:Anwendungsfalldiagramm}
\end{figure}\\
Neben der Standardanforderung eines Logins, der den Zugriff nur auf Mitglieder des \teamName beschränken soll, werden einige Anforderungsfälle für das Projekt definiert. Zunächst soll es eine Statistik-Übersicht geben, die einen groben Überblick über die einzelnen Statistiken anbietet. Hier wird nur die Anzahl der jeweiligen Berichte oder Datenquellen angezeigt. Für mehr Details können Auflistungen \zB der ungenutzten oder meistgenutzten Berichte eingesehen werden, 
die dann in einer Tabelle mit verschiedenen Attributen aufgelistet werden.

\subsubsection{Qualitätsanforderungen}
\label{sec:Qualitaetsanforderungen}
Der Softwareentwicklungsprozess der \ac{KVWL} orientiert sich an branchenüblichen Softwarequalitätsanforderungen, um Wartungskosten zu reduzieren. Zur Sicherstellung der Produktqualität wird die Norm ISO/IEC 9126\footnote{\cite{ISO9126}} verwendet, von der hier kurz die für das Projekt relevantesten Kriterien vorgestellt werden.

\paragraph{Benutzbarkeit} ~\\
\label{p:Benutzbarkeit}
Bei der Implementierung wird auf eine hohe Bedienbarkeit gesetzt. Die Benutzer sollen den Umgang mit der Anwendung schnell erlernen können und schnellstmöglich damit beginnen das Programm produktiv zu nutzen. Zur besseren Verständlichkeit werden verschiedene Farbtöne genutzt, um Nutzer über die Dringlichkeit des Handlungsbedarfs in Bezug auf die jeweilige Statistik zu informieren.

\paragraph{Funktionalität} ~\\
\label{p:Funktionalitaet}
Die aufgenommenen Anforderungen sollen zu Beginn des Projekts auf ihre Umsetzbarkeit geprüft werden, um dem Benutzer direkt im Voraus einen klaren Eindruck über die realisierbaren Funktionen der Software zu verschaffen. Außerdem werden die Ergebnisse der Datenabfragen und Methoden auf ihre Ordnungsmäßigkeit und Richtigkeit durch den Einsatz von Tests überprüft.

\paragraph{Änderbarkeit} ~\\
\label{p:Aenderbarkeit}
Wie bereits erwähnt, sollen auch nach Ende des Projektes noch weitere Funktionen hinzugefügt werden können. Dies erfordert eine einfache Analysierbarkeit und Modifizierbarkeit, um offen für noch unbekannte Anforderungen zu bleiben.

\subsection{Systementwurf}
\label{sec:Systementwurf}

\subsubsection{Zielplattform}
\label{sec:Systementwurf}
Die \ac{KVWL} setzt hauptsächlich auf Software, die in Java programmiert ist. Somit ist dies eine implizite Vorgabe für dieses Projekt. Aktuell wird die Programmiersprache Java in der Version 8 eingesetzt.

\paragraph{Server} ~\\
\label{p:Server}
 Da das Team \teamName hauptsächlich Windows-Server betreibt, muss auch \projektName auf diesen bereitgestellt werden. Diese sind bereits in ausreichender Zahl vorhanden, sodass weder Hardware noch zusätzliche virtuelle Server benötigt werden. Die Installation eines Webservers (wie Tomcat oder WildFly) ist ebenfalls nicht notwendig, weil das genutzte Spring Boot Framework bereits einen eingebetteten Webserver mitliefert.\footnote{\Vgl \cite{spring:web}} Zudem benötigt die Applikation keine Persistierungsmöglichkeiten für Daten, es muss also keine Datenbank erzeugt werden.
 
\paragraph{Clients} ~\\
\label{p:Clients}
 Die Arbeitsplätze der Anwender sind alle mit dem Betriebssystem Windows 10 mit den vorinstallierten Internetbrowsern Microsoft Edge und Mozilla Firefox ausgestattet. Der Zugriff auf \projektName kann durch einen beliebigen Browser erfolgen.

\subsubsection{Architekturdesign}
\label{sec:Architekturdesign}
Aufgrund nur weniger Vorgaben im Hinblick auf die Softwarearchitektur, mussten diesbezüglich einige Entscheidungen getroffen werden.

\paragraph{Grundlegende Architektur} ~\\
\label{p:Architektur}
Das Grundgerüst der Architektur schafft die Anwendung des Schichtenmodells. Hierbei werden einzelne Komponenten der Software einer Schicht zugeordnet. Es ist zu beachten, dass Zugriffe zwischen Schichten nur von höheren auf tiefere Schichten erfolgen dürfen und nicht umgekehrt.\footnote{\Vgl \cite{wiki:arch}}
Bei \projektName wurde eine Drei-Schichten-Architektur implementiert, bestehend aus der Datenhaltung-, der Logik- und der Präsentationsschicht. Für gewöhnlich ist die Datenhaltungsschicht sowohl für das Speichern als auch das Laden von Daten verantwortlich, bei diesem Projekt mussten jedoch keine Informationen persistiert werden.

\paragraph{Datenhaltung} ~\\
\label{p:Datenhaltung}
Zugriffe auf die Tabellen des Report-Servers werden in der Datenhaltungsschicht definiert. Sie sind das Herzstück der Applikation. Hier werden die in den Anforderungen definierten statistischen Daten aus den Tabellen der ReportServer-Datenbank extrahiert und auf Java-Entitäten abgebildet. In \Abbildung{CustomItemRepository} wird ein Repository dargestellt, dass auf Datensätze der Tabelle Catalog zugreift.
\begin{figure}[htb]
	\centering
	\includegraphicsKeepAspectRatio{Klassendiagramm_CustomItemRepository.png}{0.5}
	\caption{Klasse CustomItemRepository}
	\label{fig:CustomItemRepository}
\end{figure}

\paragraph{Logik} ~\\
\label{p:Logik}
Die Geschäftslogik von \projektName besteht im Wesentlichen aus der Abbildung von Entitäten der Datenhaltungsschicht auf Objekte der Logikschicht und der Deklaration von Service-Methoden, die diese weiterverarbeiten. Eine Übersicht der Klassen des Pakets \gqq{Mapping} findet sich in \Abbildung{Mapping}.
\begin{figure}[htb]
	\centering
	\includegraphicsKeepAspectRatio{Klassendiagramm_Mapping.png}{0.5}
	\caption{Paket \gqq{Mapping}}
	\label{fig:Mapping}
\end{figure}\\
Mithilfe dieser Mapping-Klassen werden die Entitätsobjekte in Business-Objekte konvertiert, die Clienten (aus der Präsentationsschicht) über Service-Methoden einfach verwenden können. Klassen der Präsentationsschicht können auf die gewünschte Menge von Business-Objekten über Service-Klassen zugreifen. Repräsentativ für die Service-Klassen zeigt \Abbildung{Logik} die ReportService-Schnittstelle.
\begin{figure}[htb]
	\centering
	\includegraphicsKeepAspectRatio{Klassendiagramm_ReportService.png}{0.6}
	\caption{Services in der Logikschicht}
	\label{fig:Logik}
\end{figure}

\paragraph{Präsentation} ~\\
\label{p:Praesentation}
Zur Strukturierung der Präsentationsschicht wurde das \ac{MVC}-Muster angewandt. Das Architekturmuster trennt die drei Komponenten Modell, Präsentation und Steuerung voneinander ab. Das Modell enthält Daten die dargestellt werden sollen, Views präsentieren diese und reagieren auf Benutzerinteraktionen und die Controller verwalten \bzw steuern die beiden anderen Komponenten.\footnote{\Vgl \cite{wiki:mvc}}
Die Entscheidung für diese Modell wurde aufgrund des eingesetzten Spring Frameworks getroffen. Dies bietet mit Spring MVC\footnote{\Vgl \cite{spring:mvc}} eine eingebaute unterstützung für dieses Architekturmuster.

\subsubsection{Framework}
\label{sec:Framework}
Wie schon in im Abschnitt Projektumfeld unter Punkt \ref{p:Frameworks} erwähnt, wurden diverse Frameworks eingesetzt. Strukturell jedoch beeinflusste das Spring Framework maßgeblich den Entwurf der Applikation. In der Datenhaltungsschicht wurden mithilfe von Spring Data\footnote{\Vgl \cite{spring:data}} einheitliche und komfortable Datenzugriffe realisiert. Mit Spring MVC wurde eine leicht änder- und erweiterbare Präsentationsschicht konstruiert. Nur die Logikschicht bedient sich keinerlei Funktionalitäten des Spring Frameworks. Genauere Einzelheiten hierzu finden sich im Abschnitt \ref{sec:Implementierungsphase}.

\subsubsection{Entwurf der Benutzeroberfläche}
\label{sec:Benutzeroberflaeche}
Das Webinterface von \projektName wurde mithilfe von Mock-Ups in enger Kooperation mit den Benutzern entworfen. Da ein auf die Benutzeranforderungen abgestimmtes Design ausschlaggebend für die Benutzbarkeit (\ref{p:Benutzbarkeit}) der Anwendung ist, wurden die Mock-Ups über eine Vielzahl an Iterationen hinweg kontinuierlich verbessert. So konnte eine hohe Kundenzufriedenheit am Ende der Entwurfsphase erreicht werden. Der Aufbau der \ac{GUI} orientiert sich an der unternehmensüblichen Struktur für Webseiten. Im oberen Bereich befindet sich eine Navigationsleiste mit der die Unterseiten erreicht werden können. Im Mittelteil werden die Hauptinhalte (Tabellen \etc) platziert und am unteren Rand liegt ein Footer, der die Version der Applikation anzeigt. Die verwendeten Farben entsprechen den Corporate-Design-Richtlinien der \ac{KVWL}. Eine PDF-Version des Mock-Ups kann im \Anhang{app:Mock} eingesehen werden.

\subsubsection{Maßnahmen zur Qualitätssicherung}
\label{sec:Qualitaetssicherung}
Um die Produktqualität der in Kapitel~\ref{sec:Qualitaetsanforderungen}: \nameref{sec:Qualitaetsanforderungen} beschriebenen Qualitätsanforderungen sicherzustellen, wurden eine Reihe von Maßnahmen ergriffen.

\paragraph{Anwender-Reviews} ~\\
\label{p:Reviews}
Zur Qualitätssicherung wurden in unregelmäßigen Abständen die zukünftigen Benutzer der Anwendung eingeladen, um den Fortschritt der Entwicklung zu begutachten. Dabei sollten Fehler und Unstimmigkeiten aufgedeckt werden. Diese wurden direkt im Anschluss behoben, um \zB die Arbeit an falsch verstandenen Anforderungen zu vermeiden.

\paragraph{Automatische Prüfung} ~\\
\label{p:Pruefung}
Im Zuge der Implementierung wurden Unit-Tests erstellt, die (bis zu einem bestimmten Grad) die Fähigkeit haben Fehler im Programmcode zu identifizieren. Sie werden spätestens bei jedem Build als automatisierter Test wiederholt ausgeführt.

\paragraph{Versionierung} ~\\
\label{p:Versionierung}
Für die zentrale Verwaltung des Quellcodes wurde Git verwendet. Mithilfe dieses Tools lassen sich verschiedene Versionen des Quellcodes verwalten und bei Bedarf kann dieser auf einen alten Stand zurückgesetzt werden. Dies erweist sich besonders bei der nachträglichen Erkennung von Fehlern als extrem hilfreich.

\paragraph{Buildmanagement} ~\\
\label{p:Buildmangement}
Der Erstellungsprozess der Software ist ein umfangreicher und komplexer Prozess, bei dem der Quellcode in Software-Artefakte überführt wird, die ausgeführt werden können. Da manuelle Builds sehr fehleranfällig sind, wurde der Build-Prozess mithilfe des Buildmangement-Tools Maven automatisiert. Über eine Konfigurationsdatei (\ac{POM}) werden alle Abhängigkeiten des Projekts bequem verwaltet und werden vollautomatisch beim Build der Anwendung eingebunden.

\Zwischenstand{Entwurfsphase}{Entwurf}

\subsection{Implementierung} 
\label{sec:Implementierung}
Die Codierung der Anwendung findet auf dem lokalen Windows-Rechner des Anwendungsentwicklers statt. Da die Java-Entwicklung eine der Haupttätigkeiten von Entwicklern im Geschäftsbereich IT ist, müssen hierfür nur wenige Vorbereitungen getroffen werden.

\subsubsection{Vorbereitung der Entwicklungsumgebung}
\label{sec:Entwicklungsumgebung}
Wie bereits beschrieben wurde, sind sowohl eine aktuelle Java 8 Version als auch eine \ac{IDE} auf dem Entwicklerrechner vorhanden. Es musste lediglich ein Bitbucket-Repository zur Versionsverwaltung angelegt und auf den lokalen Rechner geklont werden. Danach konnte das Basisprojekt unterstützt durch den Spring Initializr\footnote{\cite{spring:init}} über eine Weboberfläche generiert werden.

\subsubsection{Einarbeitung in die genutzten Technologien}
\label{sec:Technologien}
Nachdem die Entwicklungsumgebung eingerichtet war, konnte die Entwicklung des Projektes beginnen. Der Großteil der Technologien war bereits bekannt und wurde relativ sicher beherrscht. Die \ac{GUI} wurde mithilfe von Thymleaf-Templates aufgebaut, mit CSS gestaltet und ECMAScript gesteuert. Die Geschäftslogik wurde in einfachen Java-Klassen (\ac{POJO}) realisiert. Nur für die Datenzugriffe über \ac{JPA} wurde das für den Prüfling bisher unbekannte Framework Querydsl benutzt. Als Nachschlagewerke wurden hauptsächlich die offizielle Dokumentationsseiten und die Anleitungen von Beaeldung genutzt.

\subsubsection{Implementierung der Datenzugriffe}
\label{sec:ImplementierungDatenzugriffe}
Ausgehend von dem folgenden repräsentativen Beispiel für eine implementierte Datenabfrage, wird die Umsetzung dieses SQL-Ausdrucks durch alle Schichten hindurch beschrieben. Andere Statistiken wurden auf diesselbe Art extrahiert, verarbeitet und dargestellt. Das Resultat der Abfrage ist die geordnete Auflistung der am häufigsten ausgeführten Reports des letzten Monats.
\begin{lstlisting}[language=SQL,caption={SQL-Abfrage}]
SELECT c.itemid, c.name, c.path, c.type, COUNT(c.itemid)
FROM   Catalog c 
       INNER JOIN ExecutionLogStorage e ON c.itemid = e.reportid 
WHERE  c.type = 2
       AND c.NAME NOT LIKE 'H!_%' ESCAPE '!'
       AND e.timestart > DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP  BY c.itemid, c.name, c.type, c.path 
ORDER BY COUNT(c.itemid) DESC
\end{lstlisting}
In der Abfrage werden zunächst die Attribute eines Items aus dem Catalog selektiert. Die Tabelle Catalog wird mit dem ExecutionLogStorage über die ItemID gejoint. Durch das Type-Attribut werden alle Berichte herausgefiltert und alle Berichte mit dem Namenspräfix \gqq{H\_} herausgefiltert, da dies die Unterberichte sind. Außdem wird der Ausführungszeitpunkt auf ein Intervall von 30 Tagen beschränkt und die Ergebnismenge schließlich nach der Anzahl der Ausführungen absteigend sortiert.\\
Die äquivalente Darstellung als Java-Methode unter Verwendung von Querydsl sieht wie folgt aus:
\begin{lstlisting}[language=Java,caption={Querydsl},label=l:querydsl]
	public Page<ItemEntity> findMostExecutedReportsInRecent(Period period, Pageable pageable) {
    List<ItemEntity> mostExecutedReports = queryFactory.selectFrom(itemEntity)
        .innerJoin(itemEntity.executionLogEntities, executionLogEntity)
        .where(isReport().and(executedInTheLast(period)))
        .groupBy(itemEntity.id, itemEntity.name, itemEntity.type, itemEntity.path)
        .orderBy(itemEntity.count()
            .desc())
        .fetch();

    return DataUtils.generateItemEntityPageFromItemEntityList(mostExecutedReports, pageable);
  	}
\end{lstlisting}
Es lässt sich bei der Java-Methode unmittelbar die Ähnlichkeit zur SQL-Abfrage feststellen. Der einzige Unterschied besteht darin, dass noch ein Parameter zur Paginierung übergeben wird. Dieser bewirkt, dass immer nur der Teil der Gesamtergebnismenge zurückgegeben wird, der auch in der Tabelle in der Benutzeroberfläche angezeigt wird.

\subsubsection{Implementierung der Geschäftslogik}
\label{sec:ImplementierungGeschaeftslogik}
Damit die Präsentationsschicht die Menge der am häufigsten ausgeführten Berichte des letzten Monats abrufen kann, muss auch die Geschäftslogikschicht eine Service-Methode zum Aufruf anbieten. In dieser ruft sie die in Listing \ref{l:querydsl} definierte getMostExecutedReportsIn()-Methode der Datenzugriffsschicht auf.
\begin{lstlisting}[language=Java,caption={getMostUsedReports()-Methode des ReportServices},label={l:getMostUsedReports}]
	@Override
  	public Page<ExecutedReport> getMostUsedReports(Pageable pageable) {
    Page<ItemEntity> itemEntities = reportStatisticsService
        .getMostExecutedReportsIn(StatisticConstants.UNUSED_DEFINITION, pageable);

    return itemEntities
        .map(dataEntityToBusinessObjectMapper::convertToReport)
        .map(ExecutedReport.class::cast);
  }
\end{lstlisting}
Zunächst werden in der Methode die ItemEntities in der Variable itemEntities des Typs Page gespeichert.
Wie bereits im Abschnitt \ref{p:Logik} beschrieben, werden daraufhin die aus der Datenbank extrahierten Entitäten mithilfe der Mapper-Klassen auf Business-Objekte abgebildet. Im folgenden Listing wird eine ItemEntity (Tabelle Catalog) dargestellt.
\begin{lstlisting}[language=Java,caption={ItemEntity}]
@Getter
@Setter
@EqualsAndHashCode(of = "id")
@Entity
@Table(name = "Catalog")
@Immutable
public class ItemEntity {

  @Id
  @Column(name = "ItemID")
  private UUID id;

  private String name;
  private String path;
  private Integer type;

  @OneToMany(mappedBy = "itemEntity", cascade = CascadeType.MERGE)
  private Set<ExecutionLogEntity> executionLogEntities = new HashSet<>();

  @OneToMany(mappedBy = "itemEntity", cascade = CascadeType.MERGE)
  private Set<DataSourceEntity> dataSourceEntities = new HashSet<>();

  public ItemEntity() {
  }

  public ItemEntity(UUID id, String name, String path, Integer type) {
    this.id = id;
    this.name = name;
    this.path = path;
    this.type = type;
  }

  public void addExecutionLogEntity(ExecutionLogEntity executionLogEntity) {
    this.executionLogEntities.add(executionLogEntity);
    executionLogEntity.setItemEntity(this);
  }

  public void addDataSourceEntity(DataSourceEntity dataSourceEntity) {
    this.dataSourceEntities.add(dataSourceEntity);
    dataSourceEntity.setItemEntity(this);
  }
}
\end{lstlisting}
Man erkennt in der Klasse alle auch in der SQL-Abfrage vorhandenen Attribute und die 1:n-Beziehung zum ExecutionLogStorage in Form des executionLogEntities-Objekts. Die ItemEntities werden nun auf die Business-Objekte Report \bzw ExecutedReport abgebildet, abhängig davon, ob zu der ItemEntity ExecutionLogEntities existieren. Dieses Logik findet sich in den Mapper-Klassen. Im Anschluss sieht man die Klassen Report und ExecutedReport.
\begin{lstlisting}[language=Java,caption={Report}]
@Getter
@Setter
@EqualsAndHashCode
public class Report {

  private String name;
  private String path;

  public Report(String name, String path) {
    this.name = name;
    this.path = path;
  }
}
\end{lstlisting}
\begin{lstlisting}[language=Java,caption={ExecutedReport}]
	@Getter
	@Setter
	@EqualsAndHashCode(callSuper = true)
	public class ExecutedReport extends Report {
	
	  private LocalDateTime lastExecutedOn;
	  private String lastExecutedBy;
	  private String lastStatus;
	  private Integer sizeInBytes;
	  private Duration avgExecutionTime;
	  // period depends on UNUSED_DEFINITION
	  private Long numOfExecutionsInPeriod;
	
	  @Builder
	  private ExecutedReport(String name, String path, LocalDateTime lastExecutedOn,
		  String lastExecutedBy, String lastStatus, Integer sizeInBytes,
		  Duration avgExecutionTime, Long numOfExecutionsInPeriod) {
		super(name, path);
		this.lastExecutedOn = lastExecutedOn;
		this.lastExecutedBy = lastExecutedBy;
		this.lastStatus = lastStatus;
		this.sizeInBytes = sizeInBytes;
		this.avgExecutionTime = avgExecutionTime;
		this.numOfExecutionsInPeriod = numOfExecutionsInPeriod;
	  }
	
	  public Long getNotUsedSinceDays() {
		return ChronoUnit.DAYS.between(lastExecutedOn, LocalDateTime.now());
	  }
	}
\end{lstlisting}
Da eine Page der am häufigsten ausgeführten Reports abgerufen wird, sind alle Reports vom Typ ExecutedReport und können als entsprechend parametrisierte Page von der getMostUsedReports()-Methode (Listing \ref{l:getMostUsedReports}) zurückgegeben werden.

\subsubsection{Implementierung der Präsentationssschicht}
\label{sec:ImplementierungPraesentationsschicht}
Auch in der Präsentationsschicht findet jetzt nochmal ein Mapping zwischen den ExecutedReport Business-Objekten auf \ac{GUI}-Objekte statt. \ac{GUI}-Objekte sind einfache \acs{DTO}s (\acs{DTO}: \aclu{DTO}), die nur Attribute und Zugriffsmethoden (get(), set()) auf diese bieten. Das \ac{DTO} für einen ExectuedReport sieht wie folgt aus:
\begin{lstlisting}[language=Java,caption={ExecutedReport-DTO}]
@Getter
@Setter
@EqualsAndHashCode
public class ExecutedReport {

  private String name;
  private String path;
  private String lastExecutedOn;
  private String lastExecutedBy;
  private String lastStatus;
  private Integer sizeInBytes;
  private Long avgExecutionSeconds;
  private Long avgExecutionMinutes;
  private Long notUsedSinceDays;
  private Long numOfExecutionsInPeriod;

  @Builder
  private ExecutedReport(String name, String path, String lastExecutedOn,
      String lastExecutedBy, String lastStatus, Integer sizeInBytes,
      Long avgExecutionSeconds, Long avgExecutionMinutes, Long notUsedSinceDays,
      Long numOfExecutionsInPeriod) {
    this.name = name;
    this.path = path;
    this.lastExecutedOn = lastExecutedOn;
    this.lastExecutedBy = lastExecutedBy;
    this.lastStatus = lastStatus;
    this.sizeInBytes = sizeInBytes;
    this.avgExecutionSeconds = avgExecutionSeconds;
    this.avgExecutionMinutes = avgExecutionMinutes;
    this.notUsedSinceDays = notUsedSinceDays;
    this.numOfExecutionsInPeriod = numOfExecutionsInPeriod;
  }
}
\end{lstlisting}
Der UsageStatsController kann nun über die Service-Methode getMostUsedReports() der Präsentationsschicht, die wiederum die Service-Methode der Geschäftslogikschicht aufruft und die zurückgegebene ExecutedReport-Page auf eine Page aus \ac{DTO}s mappt, die Daten unter einer Webadresse bereitstellen. Dies sieht so aus:
\begin{lstlisting}[language=Java,caption={UsageStatsController}]
@Controller
@RequestMapping("/usage-stats")
public class UsageStatsController {

  private UsageStatisticsService usageStatisticsService;

  @Autowired
  public UsageStatsController(UsageStatisticsService usageStatisticsService) {
    this.usageStatisticsService = usageStatisticsService;
  }

  // Andere Controller-Methoden ausgelassen

  @GetMapping("/most-used-reports-table-fragment")
  public String mostUsedTableFragment(Pageable pageable, Model model) {
    Page<ExecutedReport> mostUsedReports = usageStatisticsService
        .getMostUsedReports(pageable);

    model.addAttribute("mostUsedReports", mostUsedReports);

    return "fragments/tables/most_used_reports_pageable_table";
  }
}
\end{lstlisting}
Per ECMAScript werden die Tabellendaten unter der angegebenen Adresse abgerufen und \ua mit dem folgenden Thymeleaf-Template unter Verwendung der CSS-Bibliothek Bootstrap dargestellt.
\begin{lstlisting}[language=HTML,caption={Tabellen-Fragment}]
<div layout:replace="~{templates/pageable_table_template(dataPage=${mostUsedReports})}">
  <th:block layout:fragment="table_headers">
    <th scope="col">Name</th>
    <th scope="col">Pfad</th>
    <th scope="col">Anzahl Ausfuehrungen</th>
    <th scope="col">zuletzt ausgefuehrt am</th>
  </th:block>
  <th:block layout:fragment="table_data">
    <td th:text="${item.name}"></td>
    <td th:text="${item.path}"></td>
    <td th:text="${item.numOfExecutionsInPeriod}"></td>
    <td th:text="${item.lastExecutedOn}"></td>
  </th:block>
</div>
\end{lstlisting}
Die Tabelle sieht dann bei Anzeige im Browser wie folgt aus:
\begin{figure}[htb]
	\centering
	\includegraphicsKeepAspectRatio{Tabelle.png}{1}
	\caption{HTML-Tabelle}
	\label{fig:Tabelle}
\end{figure}
Screenshots der kompletten Applikation befinden sich im \Anhang{app:adllsd}.


\subsection{Überprüfung}
\label{sec:Ueberpruefung}
Neben den beschriebenen Anwender-Reviews (Paragraph \ref{p:Reviews}) wurden auch Testklassen geschrieben, die automatisiert mit dem JUnit-Framework ausgeführt werden konnten. Es wurden nur Funktionalitäts- und keine Performancetests erstellt, da die Applikation nur von einem verhältnismäßig kleinen Nutzerkreis gleichzeitig verwendet werden muss. Exemplarisch wird im folgenden Listing ein Test der Datenzugriffsschicht-Methode findMostExecutedReportsInRecent() abgebildet.
\begin{lstlisting}[language=Java,caption={ItemEntityRepositoryFindTest}]
@ExtendWith(SpringExtension.class)
@DataJpaTest
public class ItemEntityRepositoryFindTest {

  @Autowired
  private ItemEntityRepository itemEntityRepository;

  // Andere Test-Methoden ausgelassen

  @Test
  public void testFindMostExecutedReportsInLastDayShouldReturnOneItemEntity() {
    ExecutionLogEntity executionLogEntity = ExecutionLogEntity.builder()
        .timeStart(LocalDateTime.now().minusMinutes(2))
        .timeEnd(LocalDateTime.now().minusMinutes(1)).build();
    ItemEntity itemEntity = new ItemEntity(UUID.randomUUID(), "Report1",
        "/Reports/Test/Report1",
        2);
    itemEntity.addExecutionLogEntity(executionLogEntity);
    itemEntityRepository.save(itemEntity);

    Page<ItemEntity> mostExecutedReports = itemEntityRepository.findMostExecutedReportsInRecent(
        Period.ofDays(1),
        PageRequest.of(0, 5));

    assertEquals(1, mostExecutedReports.getTotalElements());
  }
}
\end{lstlisting}
Erwähnenswert ist die Verwendung der DataJpaTest-Annotation, die für die Testklasse eine eigene speicherresidente Testdatenbank erzeugt, sodass durch die Datenmanipulationsmethoden auf dem ItemEntityRepository keine Daten in der tatsächlichen Datenbank verändert werden. Alle Tests wurden nach dem Build-Operate-Check-Muster\footnote{\cite{fitnesse:boc}} verfasst.

\Zwischenstand{Überprüfung}{Ueberpruefung}

\subsection{Abnahme}
\label{sec:Abnahme}
Die Abnahme erfolgte im \ac{CFT} \teamName durch die Ansprechpartnerin Anne Schlebusch und die zukünftige Benutzerin Vera Ahrendt. Sie bestand aus einer kurzen Vorführung der erstellten Applikation und einigen händischen Tests durch beide Teammitglieder. Die Tests bestanden im Wesentlichen nur aus einer funktionalen Überprüfung der Oberfläche. Nach der Anmeldung in der App, testeten beide alle klickbaren Funktionen der Anwendung aus und ließen sich die entsprechenden Ausgaben anzeigen. Diese glichen sie mit ähnlichen Abfragen aus den bestehenden Metadaten-Berichten ab und validierten so die korrekte Datenabfrage. Insgesamt bereitete die Abnahme keine bemerkenswerten Probleme, da die Anwender schon im Vorfeld ausreichend in das Projekt integriert wurden.

\subsection{Erstellung der Dokumentation}
\label{sec:Dokumentation}
Neben dieser Projektdokumentation wurden weitere Typen von Dokumentationen erstellt. Es sei bereits zu Beginn vermerkt, das das Verfassen aller Dokumentationsartefakte erheblich mehr Zeit in Anspruch genommen hat als zu Beginn eingeplant. Dies lässt sich aus der Tabelle \ref{tab:Dokumentation} am Ende dieser Sektion entnehmen.

\subsubsection{Projektdokumentation}
\label{sec:Projektdokumentation}
Abgesehen von dieser umfangreichen Dokumentation des Projekts wurden noch einige Aspekte auf der unternehmensinternen Kollaborationsplattform Confluence dokumentiert. Dort finden sich sowohl die Projektmotivation, Mock-Ups, Besprechungsprotokolle, als auch \ua Links zur Versionsverwaltung und zum Testserver. Diese Seite bietet einen ersten Einstieg in das Projekt.

\subsubsection{Benutzerdokumentation}
\label{sec:Benutzerdokumentation}
In der Benutzerdokumentation werden die Funktionen der Software anhand von Screenshots erklärt. Sie dient dem Anwender als Nachschlagewerk, falls Fragen während der Benutzung aufkommen. Die vollständige Benutzerdokumentation befindet sich im \Anhang{app:Benutzerdokumentation}.

\subsubsection{Quellcodedokumentation}
\label{sec:Quellcodedokumentation}
Zum besseren Verständnis des Codes und zu Wartungszwecken wurden vereinzelt Code-Kommentare eingebaut. Dies lief werkzeuggestützt durch das von Java standardmäßig mitgelieferte Werkzeug JavaDoc ab. Eine Dokumentation lässt sich so auf Knopfdruck über das Buildmanagement-Werkzeug Maven generieren.

\Zwischenstand{Erstellung der Dokumentation}{Dokumentation}